
- name: template values.yaml file
  template:
    src: "{{ chart_path }}/values.j2"
    dest: "{{ chart_path }}/values.yaml"

- name: copy env file from swarm role
  template:
    src: "{{service_env[release_name]}}"
    dest: "{{role_path}}/templates/{{ release_name }}.env"

- debug: var=release_name
  register: output

- name: template vars
  template:
    src: "{{ release_name }}.env"
    dest: "{{role_path}}/templates/{{ release_name }}.env"
  when: output.release_name != "content"

- name: template content service vars
  template:
    src: "{{ release_name }}.env"
    dest: "{{role_path}}/templates/application.conf"
  when: output.release_name == "content"

- name: create configmap
  shell: "kubectl create configmap {{ release_name }}-config --from-env-file={{role_path}}/templates/{{ release_name }}.env -n {{namespace}} --dry-run -o=yaml | kubectl apply -f -"
  when: output.release_name != "content"

- name: create content configmap
  shell: "kubectl create configmap {{ release_name }}-config --from-file={{role_path}}/templates/application.conf -n {{namespace}} --dry-run -o=yaml | kubectl apply -f -"
  when: output.release_name == "content"

- name: helm upgrade
  shell: helm upgrade --install --cleanup-on-fail {{ release_name }} {{ chart_path }} -n {{namespace}}

- name: Get the deployment rollout status
  shell: "kubectl get deployments -A | grep -i {{ release_name }} | awk -F' ' '{print $3}' | awk -F/ '{if ($1 ~ $2){exit 0} else {exit 1}}'"
  register: task_result
  until: task_result.rc == 0
  retries: 6
  delay: 30

- name: Get deployed image name
  shell: kubectl get deployments.apps {{ release_name }} -o json -n {{ namespace }} | jq -r '.spec.template.spec.containers[0].image | split("/")[1]'
  register: deployed_image

- set_fact:
   metadata_image: "{{ image_name }}:{{ image_tag }}"

- name: Compare deployed image and metadata_image
  fail:
  when: deployed_image.stdout != metadata_image
